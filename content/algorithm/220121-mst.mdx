---
title: "[JS] ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬(MST)" 
date: "2022-01-21"
emoji: "ğŸŒ±"
category: "algorithm"
---
## Spanning Tree
Undirected graphì—ì„œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ëŠ” ê·¸ë˜í”„ì˜ ì •ì  ì „ë¶€ì™€ ê°„ì„ ì˜ ë¶€ë¶„ì§‘í•©ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¶€ë¶„ ê·¸ë˜í”„ë‹¤.
ì´ë•Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì˜ ê°„ì„ ë“¤ì€ ì •ì ë“¤ì„ íŠ¸ë¦¬ í˜•íƒœë¡œ ì „ë¶€ ì—°ê²°í•´ì•¼ í•œë‹¤. íŠ¸ë¦¬ í˜•íƒœë¼ëŠ” ê²ƒì€ ê°„ì„ ë“¤ì´ **ì‚¬ì´í´ì„ ì´ë£¨ì§€ ì•Šì•„ì•¼ í•œë‹¤ëŠ”** ì¤‘ìš”í•œ ì˜ë¯¸ë¥¼ ê°€ì§„ë‹¤.

'Minimum spanning tree' ë¬¸ì œëŠ” ë§Œë“¤ ìˆ˜ ìˆëŠ” ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ì¤‘ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ë¬¸ì œë‹¤. 
ì‰½ê²Œ ë§í•˜ë©´ ê·¸ë˜í”„ì˜ ì—°ê²°ì„±ì„ ìœ ì§€í•˜ëŠ” ê°€ì¥ ë¹„ìš©ì´ ì ì€ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ê²ƒì´ë‹¤.

ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ì°¾ëŠ” ë¬¸ì œë¥¼ í’€ ìˆ˜ ìˆëŠ” ë‘ ê°€ì§€ ìœ ëª…í•œ ì•Œê³ ë¦¬ì¦˜ 'Kruskal algorithm'ê³¼ 'Prim algorithm'ì„ ì‚´í´ë³´ì.

## Kruskal
í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê°„ì„ ë“¤ë¶€í„° í•˜ë‚˜ì”© ì„ íƒ**í•˜ë©´ì„œ ìŠ¤íŒ¨íŒ… íŠ¸ë¦¬ë¥¼ ì™„ì„±í•˜ëŠ” ë°©ì‹ì´ë‹¤.
ê°„ì„ ë“¤ì„ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬í•œ ë’¤, ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ì— í•˜ë‚˜ì”© ì¶”ê°€í•´ê°€ë©´ì„œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ë¥¼ ë§Œë“ ë‹¤. ì´ë•Œ ê°„ì„ ì€ ì‚¬ì´í´ì´ ë°œìƒí•˜ì§€ ì•ŠëŠ” ê²ƒë§Œ ì„ íƒí•œë‹¤.

ê°„ì„ ì„ ì¶”ê°€í–ˆì„ ë•Œ ì´ë¯¸ ì¶”ê°€í•œ ê°„ì„ ê³¼ ì‚¬ì´í´ì„ ì´ë£¨ëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆëŠ” íš¨ìœ¨ì ì¸ ë°©ë²•ì€ '[disjoint set](https://woong-jae.com/algorithm/220114-disjoint-set)'ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.

ì–´ë–¤ ê°„ì„ ì„ ì¶”ê°€í–ˆì„ ë•Œ ê·¸ë˜í”„ì— ì‚¬ì´í´ì´ ìƒê¸°ë ¤ë©´, ê°„ì„ ì˜ ì–‘ ë ì ì´ ê°™ì€ ì»´í¬ë„ŒíŠ¸ì— ì†í•  ë•Œë‹¤.
ë”°ë¼ì„œ ë‘ ê°„ì„ ì´ ì£¼ì–´ì¡Œì„ ë•Œ ì´ë“¤ì´ ê°™ì€ ì»´í¬ë„ŒíŠ¸ì— ì†í•˜ëŠ”ì§€ í™•ì¸í•˜ê³ , ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ ë‘ ì»´í¬ë„ŒíŠ¸ë¥¼ í•©ì¹˜ë©´ ëœë‹¤.

```js
/**
* @param {Array} edges Array with objects that has three properties u(node), v(node), w(weight)
* @param {Array} selected Empty array to return MST
* @return {number}
*/
function kruskal(edges, selected) {
    let minimumWeigth = 0;
    const disjointSet = new DisjointSet(edges.length);
        
    edges.sort((a, b) => a.w - b.w);
        
    for(let edgeIndex = 0; edgeIndex < edges.length; edgeIndex++) {
        let {u, v, w} = edges[edgeIndex];
        u = disjointSet.find(u); v = disjointSet.find(v);
        // ì´ë¯¸ uì™€ vê°€ ì—°ê²°ë˜ì–´ ìˆì„ ê²½ìš° ë¬´ì‹œ
        if(u === v) continue;
        selected.push({ u, v });
        disjointSet.merge(u, v);
        minimumWeigth += w;
    }

    return minimumWeigth;
}
```

ìœ„ì˜ ì¿ ë¥´ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì€ ê°„ì„  ëª©ë¡ì˜ ì •ë ¬ì— ê±¸ë¦¬ëŠ” ì‹œê°„ $O(|E|lg|E|)$ê°€ ì§€ë°°í•˜ê³ , ì´ê²ƒì´ ì „ì²´ ì‹œê°„ ë³µì¡ë„ê°€ ëœë‹¤.

## Prim
í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì€ í•˜ë‚˜ì˜ ì‹œì‘ì ì—ì„œ ì¶œë°œí•´ì„œ ê°„ì„ ì„ í•˜ë‚˜ì”© ì¶”ê°€í•˜ë©° ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ë  ë•Œê¹Œì§€ í‚¤ì›Œê°€ëŠ” ë°©ì‹ì´ë‹¤.

ê° ì°¨ë¡€ë§ˆë‹¤ ë‹¤ìŒìœ¼ë¡œ ì¶”ê°€í•  ê°„ì„ ì„ ì°¾ëŠ”ë‹¤. 
ì´ë•Œ íŠ¸ë¦¬ì— ì†í•˜ì§€ ì•Šì€ ê° ì •ì ì— ëŒ€í•´, íŠ¸ë¦¬ì™€ ì´ ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°€ì¥ ì§§ì€ ê°„ì„ ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ê³ (`minWeight`), ê° ì •ì ì„ ìˆœíšŒí•˜ë©´ì„œ ë‹¤ìŒì— ì¶”ê°€í•  ì •ì ì„ ì°¾ì•„ì¤€ë‹¤.
ì´ëŸ° ì‹ìœ¼ë¡œ êµ¬í˜„í•˜ë©´ ê°„ì„ ì´ ì•„ë‹Œ ì •ì ì„ ìˆœíšŒí•˜ê¸° ë•Œë¬¸ì— $O(|V|)$ ì‹œê°„ì— ë‹¤ìŒì— ì¶”ê°€í•  ê°„ì„ ì„ ì°¾ì„ ìˆ˜ ìˆë‹¤.

ì •ì ì„ ì°¾ëŠ” ì‘ì—…ì€ $O(|V|)$ ì‹œê°„ì— í•  ìˆ˜ ìˆê³ , ëª¨ë“  ê°„ì„ ì€ `u`ì™€ `v`ë¥¼ íŠ¸ë¦¬ì— ì¶”ê°€ë  ë•Œ ê°ê° í•œ ë²ˆì”©, ì´ ë‘ ë²ˆì”© ê²€ì‚¬ë˜ë¯€ë¡œ ì „ì²´ ì‹œê°„ë³µì¡ë„ëŠ” $O(|V|^2+|E|)$ê°€ ëœë‹¤.
```js
/**
* @param {number} V The number of vertices
* @param {Array} adjList Array with Array of object with properties v(vertex), w(weight)
* @param {Array} selected Empty array to return MST
* @return {number}
*/
function prim(V, adjList, selected) {
    // í•´ë‹¹ ì •ì ì´ íŠ¸ë¦¬ì— í¬í•¨ë˜ì–´ ìˆë‚˜?
    const added = new Array(V).fill(false);
    // íŠ¸ë¦¬ì— ì¸ì ‘í•œ ê°„ì„  ì¤‘ í•´ë‹¹ ì •ì ì— ë‹¿ëŠ” ìµœì†Œ ê°„ì„ ì˜ ì •ë³´ë¥¼ ì €ì¥í•œë‹¤.
    const minWeight = new Array(V).fill(Infinity);
    const parent = new Array(V).fill(-1);
    // ê°€ì¤‘ì¹˜ì˜ í•©ì„ ì €ì¥í•  ë³€ìˆ˜
    let ret = 0;
    // 0ë²ˆ ì •ì ì„ ì‹œì‘ì ìœ¼ë¡œ: í•­ìƒ íŠ¸ë¦¬ì— ê°€ì¥ ë¨¼ì € ì¶”ê°€í•œë‹¤.
    minWeight[0] = parent[0] = 0;
    for (let iter = 0; iter < V; iter++) {
        // ë‹¤ìŒì— íŠ¸ë¦¬ì— ì¶”ê°€í•  ì •ì  uë¥¼ ì°¾ëŠ”ë‹¤.
        let u = -1;
        for (let v = 0; v < V; v++) {
        if (!added[v] && (u === -1 || minWeight[u] > minWeight[v])) u = v;
        }
        // (parent[u], u)ë¥¼ íŠ¸ë¦¬ì— ì¶”ê°€í•œë‹¤.
        if (parent[u] !== u) selected.push({ u, v: parent[u] });
        ret += minWeight[u];
        added[u] = true;
        // uì— ì¸ì ‘í•œ ê°„ì„  (u, v)ë“¤ì„ ê²€ì‚¬í•œë‹¤.
        for (let i = 0; i < adjList[u].length; i++) {
            let v = adjList[u][i].v, weight = adjList[u][i].w;
            if (!added[v] && minWeight[v] > weight) {
                parent[v] = u;
                minWeight[v] = weight;
            }
        }
    }
    return ret;
}
```

ì°¸ì¡°: ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í•´ê²° ì „ëµ 2